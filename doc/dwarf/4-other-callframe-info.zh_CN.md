### 5.4.3 调用栈信息（Call Frame Information）

每个处理器都有自己的方式来决定“**如何传递参数和返回值**”，这由处理器的“**ABI（应用程序二进制接口）**”定义。

**在最简单的情况下，所有函数都采用相同的方式来传递参数和返回值**，并且调试器确切地知道如何获取参数和返回值。

**但是实际上，并非每个处理器都使用相同的方式来传递参数和返回值**，不同型号的处理器ABI不同，这个好理解。

**此外，编译器可能会进行一些优化，以使生成的指令更精炼、更快**。 例如，我们创建一个简单的函数，它使用调用者的局部变量作为参数，编译器可能会将其优化（如尾递归优化），而不是将参数传递给被调用函数，这样就可以避免创建新的栈帧，当然也可能会优化寄存器的使用，也许还有其他的优化……这里一点小优化，可能会导致调试器不能准确定位调用函数的栈帧。

> 关于编译器对尾递归的优化，可以参考博文： [tail recursion call optimization]( http://www.ruanyifeng.com/blog/2015/04/tail-call.html)，当前go编译器还不支持尾递归优化，gcc是支持的。

DWARF中的调用栈信息（Call Frame Information，简称CFI）为调试器提供了如下信息，函数是如何被调用的，如何找到函数参数，如何找到调用函数（caller）的调用帧信息。 调试器借助CFI可以展开调用栈、查找上一个函数、确定当前函数的被调用位置以及传递的参数值。

与行号表一样，CFI也被编码为一系列字节码指令，这些指令由CFI状态机解释、执行，以创建完整的CFI表。 每个包含代码的地址都有一行。 第一列包含机器地址，而其他列则包含执行该地址处的指令时（fixme 执行前还是执行后）的寄存器值。 像行号表一样，完整的CFI也非常庞大。 幸运的是，两条指令之间的变化很小，因此CFI编码非常紧凑。

