### 5.4.3 调用栈信息（Call Frame Information）

#### 5.4.3.1 介绍

调试器通常需要能够查看和修改调用堆栈上任何子例程 “**活动记录**” 的状态。 一个活动记录包括：

- 子例程中的代码位置，该位置要么是调试器获得控制权时程序停止的位置（例如断点），要么是子例程进行调用或被异步事件（例如信号）中断的位置；
- 在堆栈上分配的内存区域称为“调用帧”。调用帧由堆栈上的地址标识。 我们将此地址称为“**Canonical Frame Address （规范帧地址）**”或“**CFA**”。 通常，CFA被定义为前一栈帧在调用当前子例程时的堆栈指针的值（可能与进入当前帧时的值不同）;
- 子例程在代码位置使用的一组寄存器；

通常，在调用子例程（函数）会指定一组寄存器将其状态进行保存。 如果被调用的子例程要使用一个寄存器，它就要在函数入口处保存该寄存器的原始值到栈帧中，并在退出时将其恢复。 

- 在调用栈上分配栈空间并执行保存寄存器状态任务的这部分代码，称为函数序言（prologue）；
- 执行寄存器状态恢复并销毁栈帧任务的这部分代码称为函数后记（epilogue）。

通常，序言代码实际上在子例程的开头，而后记代码在结尾。





/////////////////////////////////////

每个处理器都有自己的方式来决定“**如何传递参数和返回值**”，这由处理器的“**ABI（应用程序二进制接口）**”定义。

**在最简单的情况下，所有函数都采用相同的方式来传递参数和返回值**，并且调试器确切地知道如何获取参数和返回值。

**但是实际上，并非每个处理器都使用相同的方式来传递参数和返回值**，不同型号的处理器ABI不同，这个好理解。

**此外，编译器可能会进行一些优化，以使生成的指令更精炼、更快**。 例如，我们创建一个简单的函数，它使用调用者的局部变量作为参数，编译器可能会将其优化（如尾递归优化），而不是将参数传递给被调用函数，这样就可以避免创建新的栈帧，当然也可能会优化寄存器的使用，也许还有其他的优化……这里一点小优化，可能会导致调试器不能准确定位调用函数的栈帧。

> 关于编译器对尾递归的优化，可以参考博文： [tail recursion call optimization]( http://www.ruanyifeng.com/blog/2015/04/tail-call.html)，当前go编译器还不支持尾递归优化，gcc是支持的。

DWARF中的调用栈信息（Call Frame Information，简称CFI）为调试器提供了如下信息，函数是如何被调用的，如何找到函数参数，如何找到调用函数（caller）的调用帧信息。 调试器借助CFI可以展开调用栈、查找上一个函数、确定当前函数的被调用位置以及传递的参数值。

与行号表一样，CFI也被编码为一系列字节码指令，这些指令由CFI状态机解释、执行，以创建完整的CFI表。 每个包含代码的地址都有一行。 第一列包含机器地址，而其他列则包含执行该地址处的指令时（fixme 执行前还是执行后）的寄存器值。 像行号表一样，完整的CFI也非常庞大。 幸运的是，两条指令之间的变化很小，因此CFI编码非常紧凑。

////////////////////

调试器通常需要能够查看和修改调用堆栈上任何子例程激活的状态。 激活包括：