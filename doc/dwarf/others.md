### 5.2.6 Other Dwarf Data

#### 5.2.6.1 Line Number Table 

The Dwarf line number table contains the mapping between the memory address of executable code of a program and the source lines that corresponds to these address. 

In the simplest form, this can be looked as a matrix with one column contains the instruction address while another column contains the source line triplet (file, line, column). When setting a breakpoint of a source line, query this table to find the first instruction and set a breakpoing. When program has a fault during execucation, query current instruction address related source line to analyze it.

As we imagined, if this table were stored with one row one each instruction, this line number table would be too huge. How to compress it? Dwarf encodes it as a sequence of instructions called a line number table program. These instructions are interpreted by a simple finite state machine to recreate the complete line number table. Also, when recreating the complete line number table, only the first machine instruction of each source statement is stored into the table.

By means of this, line number table is compressed. 

#### 5.2.6.2 Macro Information 

Most debuggers have a very difficult time displaying and debugging code which has macros. The user sees the original source file, with the macros, while the code corresponds to whatever the macros generated. 

Dwarf includes the description of the macros defined in the progam. This is quite rudimentary information, but can be used by a debugger to display the values for a macro or possibly translate the macro into the corresponding source language. 

#### 5.2.6.3 Call Frame Information 

Every processor has a certain way of determining how to pass parameters and return values, this is defined by the processor’s ABI (Application Binary Interface). In the simplest case, all functions have the same way to pass parameters and return values, and the debuggers know exactly how to get the parameters and return values. 

But actually, not every processor uses the same way to pass parameters and to return values. Besides, compilers may do some optimization to make generated instructions much smaller and faster. For example, maybe a simple function is created to use caller’s local variables as parameters instead of passing parameters to callee to avoid create frame, maybe to optimize the usage of registers, maybe others… The result is a small change takes place in the optimizations and the debugger may no longer be able to walk the stack to the calling functions. 

Dwarf call frame information (CFI) provides the debugger enough information about how a function is called, how to locate the parameters to the functions, how to locate the call frame for the calling function. This information is used by the debugger to unwind the stack, locating the previous function, the location where the function is called, and the values passed. 

Like the line number table, CFI is also encoded as a sequence of instructions that are interpreted to generate a table. There’s one row for each address that contains code. The first column contains the machine address, while others contain the registers’ values at when instruction at that address is executed. Like the line number table, the complete CFI is huge. Luckily, there’s very little change between two instructions, so the CFI encoding is quite compact. 

#### 5.2.6.4 Variable Length Data 

Integer values are used throughout Dwarf to represent everything from offsets into data sections to sizes of arrays or structures. Since most values can be represented in only a few bits, this means that the data consists mostly of zeros. 

Dwarf defines a variable length integer, called Little Endian Base 128 (LEB128 for signed integers or ULEB128 for unsigned integers), which compresses the bytes taken up to represent the integers.  

Wiki: https://en.wikipedia.org/wiki/LEB128 

#### 5.2.6.5 Shrinking Dwarf data 

The encoding schemes used by Dwarf significantly reduce the size of the debugging information compared to the Dwarf v1. But unfortunately, many programs’ debugging information generated by compilers still can be very large, frequently larger than the executable code and data. 

Dwarf offers ways to further reduce the size of the debugging data. This part could be neglected here for now, as far as I am concerned. 

#### 5.2.6.6 ELF Sections

While Dwarf is defined in a way that allows it to be used with any object file format, it’s most often used with ELF.  

Each of the different kinds of Dwarf data are stored in their own section. The names of these sections all start with prefix ‘.debug_’. For improved efficiency, most references to Dwarf data use an offset from the start of the data for current compilation. This avoids the need to relocate the debugging data, which speeds up program loading and debugging. 

The ELF sections and their contents are:

1. .debug_abbrev, abbreviations used in .debug_info
2. .debug_arranges, a mapping between memory address and compilation
3. .debug_frame, call frame info
4. .debug_info, the core Dwarf data containing DIE
5. .debug_line, the line number program (sequence of instructions to generate the complete the line number table)
6. .debug_loc, location descriptions
7. .debug_macinfo, macro information
8. .debug_pubnames, a lookup table for global object and functions
9. .debug_pubtypes, a lookup table for global types
10. .debug_ranges, address ranges referenced by DIEs
11. .debug_str, string table used by .debug_info
12. .debug_types, type descriptions

