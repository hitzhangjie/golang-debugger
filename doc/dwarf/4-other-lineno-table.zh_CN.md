### 5.4.1 行号表（Line Number Table）

符号级调试器，需要知道如何将源文件中的位置与可执行对象、共享对象中的机器指令地址进行关联。 这样的关联将使调试用户可以根据源代码中的位置（源文件名+行号）指定机器指令地址（如在源码行设置断点）。调试器还可以使用此信息将当前机器指令地址转换为源文件中的位置，也可以用来控制tracee进程逐条指令执行或者逐条语句执行。

为编译单元生成的“**行号表（行号信息）**”存储在目标文件的 **.debug_line **section中，并由.debug_info节中的相应编译单元DIEs（请参阅DWARF v4中的3.1.1节）引用。

DWARF行号表，包含了可执行程序机器指令的内存地址和在源代码中的位置之间的映射关系。

**行号表长什么样子呢？可以简单地将其理解成一个矩阵**，会包含如下几列数据：

- 指令地址
- 源文件名
- 源文件中行号
- 源文件中列号
- 是否是源码语句的第一条指令
- 是否是源码词法块的第一条指令
- 其他

其中一列包含指令地址，另几列是源码位置三元组（文件、行号、列号），另两列表示当前指令是否是源码语句、词法块的第一条指令。 设置源代码行的断点时，查询该表以定位到源代码行对应的第一条指令地址，并设置断点。 当程序在执行过程中出现故障时，查询当前指令地址对应的相关的源代码行，并进行分析。

**如我们所想象的那样，如果每条指令在表中都用一行存储，那么该行号表将会巨大无比。如何压缩呢？**

- 每条源码语句可能对应着多条机器指令，实际上**只需存储第一条指令**即可，其他的都不需要存储；
- 进一步考虑将行号表数据转换为更精简的**字节码指令序列**来表示，省在哪里？相邻两机器指令之间如果某些列值相同，就可以省去对该列的操作；对于行号、列号之类的，两条指令之间行号、列号数值相差多少，存储增量也比存实际值要占用更小的存储；等等。

DWARF将行号表编码为“**行号表程序的指令序列**”。 这里的指令序列，由行号表程序（一个简单的有穷状态机）解释、执行，执行指令的过程就是创建完整行号表的过程。通过上述方法，行号表（行号信息）就被有效压缩了。



